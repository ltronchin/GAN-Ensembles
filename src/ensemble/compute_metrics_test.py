import sys
sys.path.extend([
    "./",
])
import os
import torch
from itertools import combinations
from tqdm import tqdm
import math
import time
import scipy
import numpy as np
import re
import pandas as pd
import uuid
import argparse
import yaml

from src.general_utils import util_data
from src.custom_metrics import features
from src.general_utils import util_path
from src.general_utils import util_general
import src.custom_metrics.preparation as pp
from src.general_utils import util_metric

def get_parser():

    parser = argparse.ArgumentParser(description='Compute metrics test.')

    parser.add_argument("-cfg", "--cfg_file", type=str, default="./src/configs/")
    parser.add_argument('--source_dir', type=str, default='./reports/pneumoniamnist', help='Directory name to fake samples.') #/home/lorenzo/GAN-Ensembles/reports/
    parser.add_argument('--dataset_name', type=str, default='pneumoniamnist', choices=['pneumoniamnist', 'retinamnist', 'breastmnist', 'AIforCOVID'],  help='The name of dataset')
    parser.add_argument('--gpu_ids', type=str, default='1', help='gpu ids: e.g. 0  use -1 for CPU')
    parser.add_argument('--batch_size', type=int, default='64', help='Batch size')
    parser.add_argument('--gan_models', type=util_general.parse_comma_separated_list, default='ACGAN-Mod-ADC,SAGAN,ReACGAN-ADA', help='List of GANs to enable in the ensemble')
    parser.add_argument('--gan_steps', type=util_general.parse_comma_separated_list, default='100000', help='Iter or Iters to sample each GAN')
    parser.add_argument("--post_resizer", type=str, default="friendly", help="which resizer will you use to evaluate GANs in ['legacy', 'clean', 'friendly']")
    parser.add_argument('--eval_backbone', type=str, default='InceptionV3_torch', choices=['InceptionV3_torch', 'ResNet50_torch', 'SwAV_torch', 'InceptionV3_torch__medical', 'InceptionV3_torch__truefake', 'ResNet50_torch__medical', 'ResNet50_torch__truefake'])
    parser.add_argument('--metrics_name',  type=util_general.parse_comma_separated_list, default='fid,pr,dc', help='List of metrics to compute')
    parser.add_argument('--n_samples', type=int, required=True, help='Total number of images generated by the ensemble.')
    parser.add_argument('--split', type=str, default='train', choices=['train', 'val', 'test'])

    return parser

# main
if __name__ == '__main__':

    parser = get_parser()
    args, unknown = parser.parse_known_args()

    with open(args.cfg_file) as file:
        cfg = yaml.load(file, Loader=yaml.FullLoader)

    # Directories.
    split = args.split
    source_dir = args.source_dir
    dataset_name = args.dataset_name
    n_classes = cfg['DATA']['num_classes']
    samples_dir = os.path.join(source_dir, 'samples')
    cache_dir = os.path.join(source_dir, 'features')
    backbone_dir = os.path.join(source_dir, 'backbone')

    # Parameters.
    metrics_name = args.metrics_name
    eval_backbone= args.eval_backbone
    post_resizer= args.post_resizer
    n_samples = args.n_samples
    batch_size = args.batch_size

    # Device.
    gpu_ids = int(args.gpu_ids)
    if gpu_ids >= 0:
        # Check if available.
        if not torch.cuda.is_available():
            device = torch.device('cpu')
        else:
            device = torch.device('cuda:{}'.format(gpu_ids))
    else:
        device = torch.device('cpu')

    # GANs
    gan_models = args.gan_models
    gan_steps = args.gan_steps
    gan_aval = os.listdir(samples_dir)
    filename = f'intra_test-{eval_backbone}-{post_resizer}-{n_samples}'

    # Create the entire path for each gan.
    gan_folders = [os.path.join(samples_dir, x, f'fake__{split}') for x in gan_aval if any(f'{gan_model}-train-' in x for gan_model in gan_models)]
    gan_folders = [os.path.join(x, f"step={y}") for x in gan_folders for y in gan_steps]

    eval_model = pp.LoadEvalModel(
        eval_backbone=eval_backbone,
        post_resizer=post_resizer,
        device=device,
        eval_backbone_dir=backbone_dir,
        n_classes=n_classes
    )

    df = pd.DataFrame(columns=['folder0', 'folder1', 'gan0', 'gan1', 'step0', 'step1', 'time', 'fid', 'prc', 'rec', 'f1_prc_rec', 'dns', 'cvg', 'f1_dns_cvg'])
    tot_comb = len(gan_folders)
    # Main cycle.
    with tqdm(total=tot_comb) as pbar:
        for gan_folder in gan_folders:

            print("\n")
            print(gan_folder)

            tik = time.time()
            # Dataset
            gan0_dataset = util_data.EnsembleDataset(folders=[gan_folder], weights=[1.0])
            gan1_dataset = util_data.EnsembleDataset(folders=[gan_folder], weights=[1.0])

            # Dataloder
            dataloader0 = torch.utils.data.DataLoader(gan0_dataset, batch_size=batch_size, shuffle=False)
            dataloader1 = torch.utils.data.DataLoader(gan1_dataset, batch_size=batch_size, shuffle=False)

            # Compute the features representations.
            stats0 = features.compute_feature(
                dataloader=dataloader0,
                eval_model=eval_model,
                batch_size=batch_size,
                quantize=True,
                device=device,
                cache_dir=cache_dir + gan_folder.split('samples')[-1],
                max_items=n_samples,
                capture_all=True,
                capture_mean_cov=True
            )
            mu0, sigma0 = stats0.get_mean_cov()
            feats0 = stats0.get_all_torch()
            feats0 = feats0.detach().cpu().numpy().astype(np.float64)

            stats1 = features.compute_feature(
                dataloader=dataloader1,
                eval_model=eval_model,
                batch_size=batch_size,
                quantize=True,
                device=device,
                cache_dir=cache_dir + gan_folder.split('samples')[-1],
                max_items=n_samples,
                capture_all=True,
                capture_mean_cov=True
            )
            mu1, sigma1 = stats1.get_mean_cov()
            feats1 = stats1.get_all_torch()
            feats1 = feats1.detach().cpu().numpy().astype(np.float64)

            # Compute the metrics.
            eps = 1e-6
            if 'fid' in metrics_name:
                fid = util_metric.FID(mu0, sigma0, mu1, sigma1)
                fid = float(fid)
            else:
                fid = 'NA'
            if 'pr' in metrics_name:
                prc, rec = util_metric.compute_pr(real_features=feats1, fake_features=feats0, nearest_k=5)
                prc, rec = float(prc), float(rec)
                f1_prc_rec = 2 * prc * rec / ((prc + rec) + eps)
                f1_prc_rec = float(f1_prc_rec)
            else:
                prc = 'NA'
                rec = 'NA'
                f1_prc_rec = 'NA'
            if 'dc' in metrics_name:
                dns, cvg = util_metric.compute_dc(real_features=feats1, fake_features=feats0, nearest_k=5)
                dns, cvg = float(dns), float(cvg)
                # Avoid division by 0
                f1_dns_cvg = 2 * dns * cvg / ((dns + cvg) + eps)
                f1_dns_cvg = float(f1_dns_cvg)
            else:
                dns = 'NA'
                cvg = 'NA'
                f1_dns_cvg = 'NA'

            tok = time.time()

            # Append to dataframe.
            new_row = {
                'folder0': gan_folder,
                'folder1': gan_folder,
                'gan0': re.search(f'{dataset_name}-(.*?)-train', gan_folder).group(1),
                'gan1': re.search(f'{dataset_name}-(.*?)-train', gan_folder).group(1),
                'step0': re.search('step=(\d+)', gan_folder).group(1),
                'step1': re.search('step=(\d+)', gan_folder).group(1),
                'time': float(tok - tik),
                'fid': fid,
                'prc': prc,
                'rec': rec,
                'f1_prc_rec': f1_prc_rec,
                'dns': dns,
                'cvg': cvg,
                'f1_dns_cvg': f1_dns_cvg
            }
            df_new = pd.DataFrame([new_row])
            df = pd.concat([df, df_new], ignore_index=True)

            pbar.update(1)

    df.to_excel(os.path.join(cache_dir, f'{filename}.xlsx'), index=False)

    print("May be the force with you.")





